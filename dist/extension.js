"use strict";var Y=Object.create;var x=Object.defineProperty;var U=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var J=Object.getPrototypeOf,X=Object.prototype.hasOwnProperty;var Z=(s,t)=>{for(var e in t)x(s,e,{get:t[e],enumerable:!0})},B=(s,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of V(t))!X.call(s,i)&&i!==e&&x(s,i,{get:()=>t[i],enumerable:!(o=U(t,i))||o.enumerable});return s};var y=(s,t,e)=>(e=s!=null?Y(J(s)):{},B(t||!s||!s.__esModule?x(e,"default",{value:s,enumerable:!0}):e,s)),tt=s=>B(x({},"__esModule",{value:!0}),s);var pt={};Z(pt,{activate:()=>gt,deactivate:()=>dt});module.exports=tt(pt);var g=y(require("vscode"));var w=y(require("vscode"));var j=require("child_process"),_=require("util");var A=y(require("vscode")),L=null,M=[],G=!1;function et(){return{debug:0,info:1,warn:2,error:3}}function ot(){try{return A.workspace.getConfiguration("autoCommit").get("logLevel","info")||"info"}catch{return"info"}}function S(){return L||(L=A.window.createOutputChannel("AutoCommit")),L}function O(){if(G||M.length===0)return;G=!0;let s=M.shift();s&&s(),G=!1,M.length>0&&setImmediate(O)}function E(s){M.push(s),setImmediate(O)}var it={shouldLog(s){let t=et(),e=ot();return t[s]>=t[e]},debug(s,...t){this.shouldLog("debug")&&E(()=>{let e=`[DEBUG ${new Date().toLocaleTimeString()}] ${s}`;S().appendLine(e),console.debug(e,...t)})},info(s,...t){this.shouldLog("info")&&E(()=>{let e=`[INFO  ${new Date().toLocaleTimeString()}] ${s}`;S().appendLine(e),console.log(e,...t)})},warn(s,...t){this.shouldLog("warn")&&E(()=>{let e=`[WARN  ${new Date().toLocaleTimeString()}] ${s}`;S().appendLine(e),console.warn(e,...t)})},error(s,...t){E(()=>{let e=typeof s=="string"?s:s.message||String(s),o=`[ERROR ${new Date().toLocaleTimeString()}] ${e}`;S().appendLine(o),console.error(o,...t)})},show(){S().show(!0)}},l=it;var K=y(require("vscode")),st=(0,_.promisify)(j.execFile),$=class{cwd;queue=[];running=!1;defaultTimeoutMs=3e4;constructor(t){this.cwd=t;try{let o=K.workspace.getConfiguration("autoCommit").get("gitCommandTimeoutMs");typeof o=="number"&&o>0&&(this.defaultTimeoutMs=o)}catch{}}setWorkspaceRoot(t){this.cwd=t}getWorkspaceRoot(){return this.cwd}enqueue(t){return new Promise((e,o)=>{this.queue.push({fn:t,resolve:e,reject:o}),this.processQueue()})}async processQueue(){if(this.running)return;let t=this.queue.shift();if(t){this.running=!0;try{let e=await t.fn();t.resolve(e)}catch(e){t.reject(e)}finally{this.running=!1,setImmediate(()=>this.processQueue())}}}runGitWithTimeout(t,e){let o={cwd:this.cwd??process.cwd()},i=e??this.defaultTimeoutMs;return l.debug(`runGit: git ${t.join(" ")}`,{cwd:o.cwd}),this.enqueue(async()=>{let n=st("git",t,o),r=new Promise((m,p)=>setTimeout(()=>p(new Error("Git command timed out")),i)),u=await Promise.race([n,r]);return l.debug("runGit stdout:",u.stdout||""),u.stderr&&l.warn("runGit stderr:",u.stderr),u})}async isRepo(){try{let{stdout:t}=await this.runGitWithTimeout(["rev-parse","--is-inside-work-tree"]);return String(t||"").trim()==="true"}catch{return!1}}async getCurrentBranch(){try{let{stdout:t}=await this.runGitWithTimeout(["rev-parse","--abbrev-ref","HEAD"]);return String(t||"").trim()}catch{return"HEAD"}}async isDetachedHead(){let t=await this.getCurrentBranch();return!t||t==="HEAD"}async getLastCommitMessage(){try{let{stdout:t}=await this.runGitWithTimeout(["log","-1","--pretty=%s"]);return String(t||"").trim()}catch{return""}}async getLastCommitTime(){try{let{stdout:t}=await this.runGitWithTimeout(["log","-1","--pretty=%ci"]);return String(t||"").trim()}catch{return""}}async commit(t){l.info("Staging changes..."),await this.runGitWithTimeout(["add","."]);try{l.info(`Committing: ${t}`),await this.runGitWithTimeout(["commit","-m",t]),l.info("Commit successful")}catch(e){let o=e,i=o?.stderr||o?.stdout||"";if(typeof i=="string"&&/nothing to commit/i.test(i)){l.debug("Nothing to commit");return}throw l.error("Commit failed",e),e}}async push(t="origin",e){let o=["push",t];e&&o.push(e),l.info(`Pushing to ${t}${e?`/${e}`:""}`),await this.runGitWithTimeout(o),l.info("Push complete")}async statusPorcelain(){let{stdout:t}=await this.runGitWithTimeout(["status","--porcelain"]);return l.debug("status --porcelain output:",t||""),t||""}async diffNumstat(){let{stdout:t}=await this.runGitWithTimeout(["diff","--numstat"]);return t||""}async diffNumstatCached(){let{stdout:t}=await this.runGitWithTimeout(["diff","--cached","--numstat"]);return t||""}parseNumstatToSummary(t){let e=0,o=0,i=0,n=t.split(/\r?\n/).filter(Boolean);for(let r of n){let u=r.split(/\t/);if(u.length>=2){let m=parseInt(u[0],10),p=parseInt(u[1],10);isNaN(m)||(e+=m),isNaN(p)||(o+=p),i++}}return{additions:e,deletions:o,files:i}}};var nt=[/\.(json|yaml|yml|toml|ini|config|cfg|properties)$/i,/(config|settings|\.env)/i],rt=[/\.(test|spec)\.(ts|js|java|kt|py)$/i,/test\//i,/__tests__/i,/tests?\//i],at=[/\.java$/i,/\.kt$/i,/\.kts$/i,/\.gradle$/i],ct=[/\.ts$/i,/\.tsx$/i,/\.js$/i,/\.jsx$/i],R=class{parsePorcelain(t){if(!t)return l.debug("parsePorcelain: empty"),[];let e=[],o=t.split(/\r?\n/).filter(i=>i.trim());for(let i of o){let n=i.substring(0,2),r=i.substring(2).trim();if(!r)continue;if(n.startsWith("R")||n.startsWith("C")){let m=r.match(/^(.+?)\s+->\s+(.+)$/);m?e.push({xy:n,path:m[1].trim(),renameTo:m[2].trim()}):e.push({xy:n,path:r});continue}if(n.includes("U")||n.includes("D")||n.includes("A")){let m=r.split(/\s+/)[0];e.push({xy:n,path:m||r});continue}let u=r.split(/\s+/).filter(Boolean)[0]||r;e.push({xy:n,path:u})}return l.debug("parsePorcelain -> entries:",e.length),e}analyzePorcelain(t){return this.parsePorcelain(t).map(o=>o.renameTo?`${o.path} -> ${o.renameTo}`:o.path)}groupByFileType(t){let e={java:[],ts:[],json:[],config:[],test:[],other:[]};for(let o of t){let i=o.split(/\s+->\s+/)[0];rt.some(n=>n.test(i))?e.test.push(i):at.some(n=>n.test(i))?e.java.push(i):ct.some(n=>n.test(i))?e.ts.push(i):nt.some(n=>n.test(i))?e.config.push(i):/\.json$/i.test(i)?e.json.push(i):e.other.push(i)}return e}inferCommitType(t){return t.test.length>0&&t.java.length===0&&t.ts.length===0?"test":t.config.length>0&&t.java.length===0&&t.ts.length===0&&t.other.length===0?"chore":t.java.length>0||t.ts.length>0?"feat":t.config.length>0?"chore":"feat"}inferScope(t,e){if(e&&/^feature\/(.+)$/i.test(e)){let r=e.match(/^feature\/(.+)$/i);return r?r[1].replace(/[/\\]/g,"-"):"robot"}let o=t[0];if(!o)return"robot";let n=o.split(/\s+->\s+/)[0].replace(/\\/g,"/").split("/");return n.length>=2?n[n.length-2]:"robot"}generateCommitMessageFromPorcelain(t,e){let o=this.parsePorcelain(t),i=o.map(h=>h.renameTo?`${h.path} -> ${h.renameTo}`:h.path);if(i.length===0)return"chore: no changes";let n=this.groupByFileType(i),r=this.inferCommitType(n),u=this.inferScope(i,e),m=[...n.java,...n.ts,...n.other].filter(Boolean),p=m[0]?m[0].replace(/^.*[/\\]/,"").replace(/\.[^.]+$/,""):"files";if(i.length===1){let h=o[0].xy.startsWith("D")?"remove":o[0].xy.startsWith("R")?"rename":"update";return`${r}(${u}): ${h} ${p}`}let v=i.length-1;return`${r}(${u}): update ${p} and ${v} related file${v>1?"s":""}`}generateCommitMessage(t){if(!t||t.length===0)return"chore: no changes detected";let e=t.map(o=>` M ${o}`).join(`
`);return this.generateCommitMessageFromPorcelain(e)}};var P=y(require("vscode")),C=class{static getActiveWorkspaceRoot(){let t=P.workspace.workspaceFolders;if(!t||t.length===0)return;if(t.length===1)return t[0].uri.fsPath;let e=P.window.activeTextEditor;if(e?.document.uri){let o=P.workspace.getWorkspaceFolder(e.document.uri);if(o)return o.uri.fsPath}return t[0].uri.fsPath}static getAllWorkspaceRoots(){let t=P.workspace.workspaceFolders;return!t||t.length===0?[]:t.map(e=>e.uri.fsPath)}};var Q=y(require("vscode")),ut=500,H=5,mt=3e3,N=class{lastChangeTime=0;rapidEditCount=0;saveCount=0;lastSaveTime=0;shouldSkipCommit(t,e){let o=Q.workspace.getConfiguration("autoCommit"),i=o.get("minChanges",0),n=o.get("debounceSaveSpam",!0),r=o.get("rapidEditThresholdMs",ut),u=Date.now(),p=t.split(/\r?\n/).filter(f=>f.trim()).length,v=e??i;if(v>0&&p<v)return{skip:!0,reason:`minChanges (${v}) not met`};let h=o.get("skipSingleLineChange",!1);if(n&&r>0){if(u-this.lastChangeTime<r){if(this.rapidEditCount++,this.rapidEditCount>=H)return{skip:!0,reason:"rapid edits detected"}}else this.rapidEditCount=0;this.lastChangeTime=u}return n&&(u-this.lastSaveTime>mt&&(this.saveCount=0),this.saveCount>=H)?{skip:!0,reason:"save spam detected"}:{skip:!1}}recordChange(){this.lastChangeTime=Date.now()}recordSave(){this.saveCount++,this.lastSaveTime=Date.now()}reset(){this.rapidEditCount=0,this.saveCount=0}};var I=y(require("vscode"));async function z(s){let{changedFiles:t,diffSummary:e,generatedMessage:o,branch:i}=s,n=t.slice(0,15).map(f=>f.renameTo?`${f.path} \u2192 ${f.renameTo}`:f.path),r=Math.max(0,t.length-15),u=r>0?`${n.join(", ")}, ... +${r} more`:n.join(", "),m=`+${e.additions} -${e.deletions} lines`,p=`Branch: ${i} | ${m}
Files: ${u}

Message: ${o}`,v=[{label:"$(check) Approve",description:"Commit with generated message",detail:p},{label:"$(edit) Edit Message",description:"Modify commit message",detail:p},{label:"$(close) Cancel",description:"Cancel commit",detail:p}],h=await I.window.showQuickPick(v,{placeHolder:o,title:`AutoCommit Preview | ${t.length} files | ${m}`,ignoreFocusOut:!0});if(!h)return{action:"cancel"};if(h.label.includes("Approve"))return{action:"approve",message:o};if(h.label.includes("Edit")){let f=await I.window.showInputBox({value:o,prompt:"Edit commit message",title:"AutoCommit: Edit Message",validateInput:k=>k?.trim()?null:"Message cannot be empty"});return f?.trim()?{action:"approve",message:f.trim()}:{action:"cancel"}}return{action:"cancel"}}var lt="autoCommit.metrics.",D=class{constructor(t){this.context=t}getKey(t){return`${lt}${t}`}async getCommitCount(){return await this.context.globalState.get(this.getKey("commitCount"),0)}async getAutoCount(){return await this.context.globalState.get(this.getKey("autoCount"),0)}async getManualCount(){return await this.context.globalState.get(this.getKey("manualCount"),0)}async recordCommit(t){let e=await this.getCommitCount()+1;if(await this.context.globalState.update(this.getKey("commitCount"),e),t){let o=await this.getAutoCount()+1;await this.context.globalState.update(this.getKey("autoCount"),o)}else{let o=await this.getManualCount()+1;await this.context.globalState.update(this.getKey("manualCount"),o)}await this.context.globalState.update(this.getKey("lastCommitTime"),new Date().toISOString())}async recordDebounce(t){await this.context.globalState.update(this.getKey("lastDebounceMs"),t);let e=await this.context.globalState.get(this.getKey("avgDebounceMs"),0),o=await this.context.globalState.get(this.getKey("debounceCount"),0),i=o+1,n=(e*o+t)/i;await this.context.globalState.update(this.getKey("avgDebounceMs"),n),await this.context.globalState.update(this.getKey("debounceCount"),i)}async getMetrics(){return{commitCount:await this.getCommitCount(),autoCount:await this.getAutoCount(),manualCount:await this.getManualCount(),lastDebounceMs:await this.context.globalState.get(this.getKey("lastDebounceMs"),0),avgDebounceMs:await this.context.globalState.get(this.getKey("avgDebounceMs"),0),lastCommitTime:await this.context.globalState.get(this.getKey("lastCommitTime"))}}};var W=class{constructor(t){this.context=t;let e=C.getActiveWorkspaceRoot();this.git=new $(e),this.analyzer=new R,this.debounceEngine=new N,this.metrics=new D(t),l.info("SessionManager initialized",{root:e}),this.setupListeners(),this.loadConfigAndMaybeSchedule(),this.setupWorkspaceWatcher()}timeout=null;intervalHandle=null;git;analyzer;debounceEngine;metrics;enabled=!0;statusEmitter=new w.EventEmitter;onDidCommit=this.statusEmitter.event;commitMutex=!1;setupWorkspaceWatcher(){this.context.subscriptions.push(w.window.onDidChangeActiveTextEditor(()=>{let t=C.getActiveWorkspaceRoot(),e=this.git.getWorkspaceRoot();t&&t!==e&&(this.git.setWorkspaceRoot(t),l.debug("Workspace root updated",{newRoot:t}))}))}loadConfigAndMaybeSchedule(){let t=w.workspace.getConfiguration("autoCommit"),e=t.get("mode","safe"),o=t.get("intervalMs",300*1e3);e==="auto"&&this.startInterval(o)}setupListeners(){this.context.subscriptions.push(w.workspace.onDidSaveTextDocument(()=>{this.debounceEngine.recordSave(),this.registerChange()}),w.workspace.onDidChangeTextDocument(()=>{this.debounceEngine.recordChange(),this.registerChange()})),l.debug("SessionManager listeners registered")}setEnabled(t){this.enabled=t,this.statusEmitter.fire(`enabled:${t}`),l.info(`AutoCommit enabled: ${t}`)}startInterval(t){this.intervalHandle&&clearInterval(this.intervalHandle),this.intervalHandle=setInterval(()=>this.commitNow(!1),t)}registerChange(){if(!this.enabled)return;let t=w.workspace.getConfiguration("autoCommit");if(t.get("mode","safe")==="manual")return;let o=t.get("debounceMs",2e3);this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(()=>this.commitNow(!1).catch(i=>{l.error("AutoCommit commit failed",i),w.window.showErrorMessage(`AutoCommit: ${i?.message||i}`)}),o)}async commitNow(t=!0){let e=C.getActiveWorkspaceRoot();if(!e){this.statusEmitter.fire("noWorkspace");return}this.git.setWorkspaceRoot(e);let o=w.workspace.getConfiguration("autoCommit"),i=o.get("mode","safe");if(this.commitMutex){l.debug("commitNow: skipped (mutex)");return}this.commitMutex=!0;try{if(this.statusEmitter.fire("progress:start"),!await this.git.isRepo()){this.statusEmitter.fire("notGitRepo"),this.statusEmitter.fire("progress:end");return}let r=await this.git.statusPorcelain();if(!r||!r.trim()){this.statusEmitter.fire("progress:end");return}let u=this.debounceEngine.shouldSkipCommit(r);if(u.skip&&!t){l.debug("commitNow: skipped",u.reason),this.statusEmitter.fire("progress:end");return}let m=await this.git.getCurrentBranch();if(await this.git.isDetachedHead()&&w.window.showWarningMessage("AutoCommit: Detached HEAD state. Commit may create orphan commit."),o.get("protectMainBranch",!0)&&i==="safe"&&(m==="main"||m==="master")&&await w.window.showWarningMessage(`You are on ${m}. AutoCommit usually avoids main/master. Proceed?`,"Yes","No")!=="Yes"){this.statusEmitter.fire("progress:end");return}let h=this.analyzer.parsePorcelain(r),f=this.analyzer.generateCommitMessageFromPorcelain(r,m),k=await this.git.diffNumstat(),c=this.git.parseNumstatToSummary(k+`
`+await this.git.diffNumstatCached());if(i==="safe"){let d=await z({changedFiles:h,diffSummary:c,generatedMessage:f,branch:m});if(d.action==="cancel"){this.statusEmitter.fire("progress:end");return}d.action==="approve"&&d.message&&await this.doCommit(d.message)}else i==="auto"?await this.doCommit(f):await this.doCommit(f);await this.metrics.recordCommit(!t)}catch(n){throw this.statusEmitter.fire("error"),n}finally{this.commitMutex=!1,this.statusEmitter.fire("progress:end")}}async doCommit(t){await this.git.commit(t),this.statusEmitter.fire(`commit:${t}`),l.info("commitNow: commit finished")}async pushNow(){let t=C.getActiveWorkspaceRoot();if(!t)return;if(this.git.setWorkspaceRoot(t),!await this.git.isRepo()){w.window.showErrorMessage("Not a Git repository.");return}try{await this.git.push()}catch(o){throw l.error("pushNow failed",o),o}}dispose(){this.timeout&&clearTimeout(this.timeout),this.intervalHandle&&clearInterval(this.intervalHandle),l.debug("SessionManager disposed")}};var b,a;async function gt(s){let t=C.getActiveWorkspaceRoot(),o=await new $(t).isRepo();b=new W(s),a=g.window.createStatusBarItem(g.StatusBarAlignment.Left,100),a.command="auto-commit-vscode-extension.showMenu";let n=g.workspace.getConfiguration("autoCommit").get("enabled",!0),r=async c=>{if(a){if(c?.notGitRepo){a.text="$(git-branch) AutoCommit: Not a Git repo",a.tooltip="Current folder is not a Git repository",a.backgroundColor=void 0;return}if(c?.error){a.text=`$(error) AutoCommit: ${n?"ON":"OFF"}`,a.tooltip="Last operation failed",a.backgroundColor=new g.ThemeColor("statusBarItem.errorBackground");return}c?.text&&(a.text=c.text),c?.tooltip&&(a.tooltip=c.tooltip),a.backgroundColor=void 0,a.show()}};!o&&t?await r({notGitRepo:!0}):(a.text=`$(git-commit) AutoCommit: ${n?"ON":"OFF"}`,a.tooltip="AutoCommit: click for actions",a.show());let u="",m="",p=()=>{let c=C.getActiveWorkspaceRoot();return new $(c)};b.onDidCommit(async c=>{if(a){if(c==="notGitRepo"){await r({notGitRepo:!0});return}if(c==="error"){await r({error:!0});return}if(c==="progress:start"){a.text="$(sync~spin) AutoCommit: ON (committing...)",a.tooltip="Committing...",a.show();return}if(c==="progress:end"){let T=await p().getCurrentBranch(),F=u?`Last: ${u}`:"",q=m?` | ${m}`:"";a.text="$(git-commit) AutoCommit: ON",a.tooltip=`Branch: ${T}${F?`
${F}`:""}${q}`,a.backgroundColor=void 0,a.show();return}if(c.startsWith("commit:")){u=c.slice(7),m=new Date().toLocaleTimeString();let T=await p().getCurrentBranch();a.text="$(git-commit) AutoCommit: ON",a.tooltip=`Branch: ${T}
Last: ${u}
${m}`,a.show();return}if(c.startsWith("enabled:")){let d=c.split(":")[1]==="true";a.text=`$(git-commit) AutoCommit: ${d?"ON":"OFF"}`,a.tooltip="AutoCommit: click for actions",a.show()}}});let v=g.commands.registerCommand("auto-commit-vscode-extension.showMenu",async()=>{let c=await g.window.showQuickPick([{label:"Commit Now",description:"Create an automatic commit now"},{label:"Push Now",description:"Push commits to remote"},{label:"Toggle AutoCommit",description:"Enable/disable automatic commits"}],{placeHolder:"AutoCommit actions"});if(c){if(c.label==="Commit Now")try{a.text="$(sync~spin) AutoCommit: ON (committing...)",await b?.commitNow(!0)}catch(d){g.window.showErrorMessage(`AutoCommit: ${d?.message||d}`)}else if(c.label==="Push Now")await b?.pushNow();else if(c.label==="Toggle AutoCommit"){let d=g.workspace.getConfiguration("autoCommit"),T=d.get("enabled",!0);await d.update("enabled",!T,g.ConfigurationTarget.Global),b?.setEnabled(!T)}}});s.subscriptions.push(v);let h=g.commands.registerCommand("auto-commit-vscode-extension.toggle",async()=>{let c=g.workspace.getConfiguration("autoCommit"),d=c.get("enabled",!0);await c.update("enabled",!d,g.ConfigurationTarget.Global),g.window.showInformationMessage(`AutoCommit ${d?"disabled":"enabled"}`),b?.setEnabled(!d)}),f=g.commands.registerCommand("auto-commit-vscode-extension.commitNow",async()=>{try{await b?.commitNow(!0),g.window.showInformationMessage("AutoCommit: commit complete")}catch(c){g.window.showErrorMessage(`AutoCommit error: ${c?.message||c}`)}}),k=g.commands.registerCommand("auto-commit-vscode-extension.pushNow",async()=>{await b?.pushNow()});s.subscriptions.push(h,f,k,{dispose:()=>b?.dispose()})}function dt(){b?.dispose()}0&&(module.exports={activate,deactivate});
